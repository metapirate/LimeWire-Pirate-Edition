package com.limegroup.gnutella.malware;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.limewire.core.api.malware.AntivirusUpdateType;
import org.limewire.core.api.malware.VirusNfoUrl;
import org.limewire.core.api.malware.VirusUpdatesUrl;
import org.limewire.core.settings.MalwareSettings;
import org.limewire.inject.EagerSingleton;
import org.limewire.io.Expand;
import org.limewire.io.InvalidDataException;
import org.limewire.lifecycle.Asynchronous;
import org.limewire.lifecycle.Join;
import org.limewire.lifecycle.Service;
import org.limewire.lifecycle.ServiceRegistry;
import org.limewire.listener.EventListener;
import org.limewire.listener.EventListenerList;
import org.limewire.logging.Log;
import org.limewire.logging.LogFactory;
import org.limewire.util.CommonUtils;
import org.limewire.util.FileUtils;

import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.name.Named;
import com.limegroup.gnutella.malware.NFOFile.Entry;

@EagerSingleton
class VirusDefinitionManagerImpl implements VirusDefinitionManager, Service {

    private static final Log LOG = LogFactory.getLog(VirusDefinitionManagerImpl.class);
    private static final int MAX_RETRIES = 2;

    private final File mementoFile = new File(CommonUtils.getUserSettingsDir(), "vdef.dat");
    private final File mementoBackupFile = new File(CommonUtils.getUserHomeDir(), "vdef.bak");
    private final Provider<VirusDefinitionDownloader> downloaderFactory;
    private final Provider<VirusScanner> virusScannerProvider;
    private final Provider<String> updatesURL;
    private final Provider<String> nfoURL;
    private final ScheduledExecutorService backgroundExecutor;
    private final EventListenerList<VirusDefinitionVersionEvent> listeners;
    private final AtomicBoolean checking;
    private final AtomicBoolean scheduledFutureDefinitionCheck;
    private int retries = 0;

    @Inject
    VirusDefinitionManagerImpl(Provider<VirusDefinitionDownloader> downloader,
            Provider<VirusScanner> virusScanner,
            @VirusUpdatesUrl Provider<String> updatesURL,
            @VirusNfoUrl Provider<String> nfoURL,
            @Named("backgroundExecutor") ScheduledExecutorService backgroundExecutor) {
        LOG.debug("Creating VirusDefinitionManagerImpl");
        this.downloaderFactory = downloader;
        this.virusScannerProvider = virusScanner;
        this.updatesURL = updatesURL;
        this.nfoURL = nfoURL;
        this.backgroundExecutor = backgroundExecutor;
        listeners = new EventListenerList<VirusDefinitionVersionEvent>();
        checking = new AtomicBoolean(false);
        scheduledFutureDefinitionCheck = new AtomicBoolean(false);
    }

    @Inject
    void register(ServiceRegistry registry) {
        registry.register(this);
    }

    @Override
    public String getServiceName() {
        return "Virus Definition Service";
    }

    @Override
    public void initialize() {
        scheduleNextCheck();
    }

    /**
     * Starts this service, checking & downloading new definitions
     * as necessary is virus scanning is supported.
     */
    @Override @Asynchronous(join=Join.NONE)
    public void start() {
        LOG.debug("Starting Virus Definition Checking..");

        if(isScanningAllowed()) {
            LOG.debug("Virus scanner is supported!");
            VirusDefinitionDownloadMemento memento = loadMemento();
            if(memento != null) {
                LOG.debug("Continuing from memento...");
                try {
                    startMementoDownload(memento);
                } catch(InvalidDataException ide) {
                    eraseMementos(memento);
                    LOG.debug("Invalid memento, starting full check", ide);
                    checkForDefinitions();
                }
            }
            else {
                checkForDefinitions();
            }
        }
    }

    @Override
    public void stop() {
    }

    @Override
    public void addListener(EventListener<VirusDefinitionVersionEvent> listener) {
        listeners.addListener(listener);
    }

    @Override
    public boolean removeListener(EventListener<VirusDefinitionVersionEvent> listener) {
        return listeners.removeListener(listener);
    }

    private boolean isScanningAllowed() {
        // Check both for enabledness & supportedness before scanning.
        // (enabledness alone checks shouldBeSupported && ENABLED)
        if(!virusScannerProvider.get().isEnabled() || !virusScannerProvider.get().isSupported()) {
            LOG.debug("Not supported");
            return false;
        } else if(!MalwareSettings.CHECK_FOR_VIRUS_DEFINITION_UPDATES.getValue()) {
            LOG.debug("Checking for virus definition updates is disabled");
            return false;
        } else {
            return true;
        }
    }

    /** Loads the saved memento from disk, erasing it if it's invalid. */
    VirusDefinitionDownloadMemento loadMemento() {
        if(!mementoFile.exists()) {
            LOG.debug("No memento file exists, unable to load a memento");
            return null;
        }

        try {
            Object read = FileUtils.readObject(mementoFile);
            // Only return the memento if it's for a full file & its incomplete file still exists.
            if(read instanceof VirusDefinitionDownloadMemento) {
                VirusDefinitionDownloadMemento memento = (VirusDefinitionDownloadMemento) read;
                LOG.debugf("Loaded memento file {0}", memento);
                if(memento.getAntivirusUpdateType() == AntivirusUpdateType.FULL
                        && memento.getIncompleteFile() != null
                        && memento.getIncompleteFile().exists()
                        && memento.getUri() != null) {
                    return memento;
                } else {
                    eraseMementos(memento);
                }
                return null;
            }
        } catch(Throwable t) {
            LOG.error("Error reading memento file", t);
        }
        eraseMementos(null);
        return null;
    }

    /** Erases any mementos from disk. */
    private void eraseMementos(VirusDefinitionDownloadMemento memento) {
        if(memento != null && memento.getIncompleteFile() != null) {
            memento.getIncompleteFile().delete();
        }
        mementoFile.delete();
        mementoBackupFile.delete();
    }

    /** Notification that downloads are completed -- erases all saved mementos. */
    private void downloadsFinished() {
        eraseMementos(null);
        checking.set(false);
    }

    @Override
    public void checkForDefinitions() {
        if(checking.getAndSet(true)) {
            LOG.debug("Already checking, can't check definitions");
            return;
        }

        if(!isScanningAllowed()) {
            LOG.debug("Won't check for definitions since scanning is not allowed");
            return;
        }

        fetchNfo();
    }

    /** Starts a download from a memento. */
    private void startMementoDownload(VirusDefinitionDownloadMemento memento) throws InvalidDataException {
        if(checking.getAndSet(true)) {
            LOG.debug("Already checking, can't restart from memento");
            return;
        }

        assert memento.getAntivirusUpdateType() == AntivirusUpdateType.FULL;
        VirusDefinitionDownloader downloader = downloaderFactory.get();
        try {
            downloader.initFromMemento(memento);
        } catch(Throwable t) {
            throw new InvalidDataException("Invalid memento!", t);
        }

        downloader.setAttribute(VirusDefinitionDownloaderKeys.TYPE, AntivirusUpdateType.FULL, false);
        downloader.fetch(new UpdateHandler(), mementoFile, mementoBackupFile);
    }

    private void doUpdates(NFOFile file) {
        List<Entry> updatesToInstall = new ArrayList<Entry>();

        int version = virusScannerProvider.get().getDefinitionsVersion();

        for(Entry entry : file.getIncrementalEntries()) {
            if(entry.getVersion() == version + 1) {
                version++;
                updatesToInstall.add(entry);
                if(LOG.isDebugEnabled())
                    LOG.debug("Scheduling incremental update " + version);
            } else if(entry.getVersion() > version + 1) {
                if(LOG.isDebugEnabled())
                    LOG.debug("Non-contiguous update " + entry.getVersion());
            }
        }

        if((updatesToInstall.isEmpty() || updatesToInstall.size() > MalwareSettings.MAXIMUM_INCREMENTAL_UPDATES.getValue()) && !file.getFullEntries().isEmpty()) {
            Entry latestFullUpdate = file.getFullEntries().last();

            if(latestFullUpdate.getVersion() > virusScannerProvider.get().getDefinitionsVersion()) {                
                if(LOG.isDebugEnabled() &&  updatesToInstall.size() > MalwareSettings.MAXIMUM_INCREMENTAL_UPDATES.getValue()){
                    LOG.debug("Preferring full update over " + updatesToInstall.size() + " incremental updates (Maximum incrementals=" + 
                            MalwareSettings.MAXIMUM_INCREMENTAL_UPDATES.getValue()+")");
                }

                updatesToInstall.clear();
                updatesToInstall.add(latestFullUpdate);
                version = latestFullUpdate.getVersion();
                if(LOG.isDebugEnabled())
                    LOG.debug("Scheduling full update " + version);
            }
        }

        if(updatesToInstall.isEmpty()) {
            LOG.debug("Virus definitions are up to date");
            listeners.broadcast(new VirusDefinitionVersionEvent(version));
            downloadsFinished();
            return;
        }

        UpdatesScheduler scheduler = new UpdatesScheduler(updatesToInstall);
        scheduler.start();
    }

    /** Fetches the NFO file, possibly restarting a memento if it's non-null. */
    private void fetchNfo() {
        // Download the NFO file
        try {
            URI nfo = new URI(nfoURL.get() + "current.nfo");
            VirusDefinitionDownloader downloader = downloaderFactory.get();
            downloader.setUriAndName(nfo, "current.nfo");                  
            downloader.setAttribute("antivirus_update_type", AntivirusUpdateType.CHECKING, false);
            downloader.fetch(new NFOHandler(), null, null);
        } catch(URISyntaxException e) {
            LOG.debug("Invalid URI for current.nfo", e);
            scheduleNextCheck();
        }
    }

    private boolean isUpdateCompatibleWithLibrary(File updateDir) throws InvalidLibraryException, IOException {
        long libraryV;
        try {
            libraryV = virusScannerProvider.get().getLibraryBuildVersion();
        } catch(IOException iox) {
            throw new InvalidLibraryException(iox);
        }
        File nfo = new File(updateDir, "version.nfo");
        String required = VirusUtils.getNfoValue(nfo, "REQUIRED_BIN_RELEASE_VERSION");
        long reqV = parseVersion(required);
        LOG.debugf("Library version: {0}, required version string: {1}, required version: {2}", libraryV, required, reqV);
        return libraryV > reqV;
    }

    private long parseVersion(String version) throws IOException {
        int idx = version.lastIndexOf(".");
        if(idx + 1 < version.length()) {
            try {
                return Long.parseLong(version.substring(idx + 1));
            } catch(NumberFormatException nfe) {
                throw new IOException("Invalid version: " + version, nfe);
            }
        }
        throw new IOException("Invalid version: " + version);
    }

    private void scheduleNextCheck() {
        if(scheduledFutureDefinitionCheck.getAndSet(true)) {
            LOG.debug("Already scheduled future definition check. Ignoring scheduling request.");
            return;
        }

        if(isScanningAllowed()) {
            Runnable check = new Runnable() {
                @Override
                public void run() {
                    if(isScanningAllowed()) {
                        LOG.debug("Scheduled check running");
                        scheduleNextCheck();
                        fetchNfo();
                    } else {
                        LOG.debug("Scheduled check cancelled");
                    }
                }
            };
            LOG.debug("Scheduling next check in 24 hours");
            backgroundExecutor.schedule(check, 24, TimeUnit.HOURS);
        }
    }

    private void considerRetrying() {
        if(virusScannerProvider.get().getDefinitionsVersion() == 0 &&
                retries++ < MAX_RETRIES) {
            LOG.debug("Retrying");
            eraseMementos(null);
            fetchNfo();
        } else {
            if(LOG.isDebugEnabled()) {
                if(retries-1 >= MAX_RETRIES) {
                    LOG.debug("Not retrying, max retries exceeded");
                } else {
                    LOG.debug("Not retrying, VDB version > 0");
                }
            }
            retries = 0;
            downloadsFinished();
        }
    }

    private class UpdatesScheduler {

        private final List<NFOFile.Entry> entries;
        private final int totalIncrementalUpdates;
        private final UpdateHandler handler;

        public UpdatesScheduler(List<NFOFile.Entry> entries) {
            this.entries = entries;

            // Get the number of incremental updates in the list.  
            //  (Assume full update always first)
            if(entries.isEmpty() ||
                    entries.get(0).getType() == AntivirusUpdateType.FULL) {
                totalIncrementalUpdates = 0;
            } else {
                totalIncrementalUpdates = entries.size();
            }

            handler = new UpdateHandler(this);
        }

        private void start() {
            processNextEntry();
        }

        private void notifyUpdateComplete() {
            processNextEntry();
        }

        private void processNextEntry() {
            if(entries.size() > 0) {
                try {
                    NFOFile.Entry entry = entries.remove(0);
                    download(entry);  
                } catch(URISyntaxException e) {
                    // Carry on with what we've got
                    LOG.debug("Invalid update URI", e);
                }
            } else {
                downloadsFinished();
            }
        }

        private void download(NFOFile.Entry entry) throws URISyntaxException {
            URI updateURI = new URI(updatesURL.get() + entry.getPath());
            VirusDefinitionDownloader downloader = downloaderFactory.get();
            downloader.setUriAndName(updateURI, entry.getPath());                  
            handler.setCurrentUpdateType(entry.getType());

            downloader.setAttribute(VirusDefinitionDownloaderKeys.TYPE, entry.getType(), false);
            if(entry.getType() == AntivirusUpdateType.INCREMENTAL) {
                downloader.setAttribute(VirusDefinitionDownloaderKeys.COUNT, Integer.valueOf(totalIncrementalUpdates), false);
                downloader.setAttribute(VirusDefinitionDownloaderKeys.INDEX, Integer.valueOf(totalIncrementalUpdates - entries.size()), false);
                downloader.fetch(handler, null, null);
            } else {
                downloader.fetch(handler, mementoFile, mementoBackupFile);
            }
        }
    }

    private class UpdateHandler implements VirusDefinitionHandler {

        private final UpdatesScheduler scheduler;
        private AntivirusUpdateType currentUpdateType;

        private UpdateHandler() {
            currentUpdateType = AntivirusUpdateType.FULL;
            this.scheduler = null;
        }

        private UpdateHandler(UpdatesScheduler scheduler) {
            this.scheduler = scheduler; 
        }

        private void setCurrentUpdateType(AntivirusUpdateType type) {
            currentUpdateType = type;
        }

        @Override
        public void downloadSucceeded(File defs) {
            File temp = VirusUtils.getTemporaryDirectory();
            FileUtils.forceDeleteRecursive(temp);
            temp.mkdirs();
            temp.mkdir();
            try {
                Expand.expandFile(defs, temp, true);
                String name = FileUtils.getFilenameNoExtension(defs.getName());
                File updateDir = new File(temp, name);
                if(!updateDir.exists())
                    throw new IOException("Unexpected zip format");
                if(!isUpdateCompatibleWithLibrary(updateDir)) {
                    MalwareSettings.CHECK_FOR_VIRUS_DEFINITION_UPDATES.set(false);
                    throw new IOException("Update is not compatible with library");
                }

                switch(currentUpdateType) {
                case INCREMENTAL :
                    virusScannerProvider.get().loadIncrementalUpdate(updateDir);
                    break;
                case FULL :
                    virusScannerProvider.get().loadFullUpdate(updateDir);
                    break;
                }

                int version = virusScannerProvider.get().getDefinitionsVersion();
                listeners.broadcast(new VirusDefinitionVersionEvent(version));

                if(scheduler != null) {
                    scheduler.notifyUpdateComplete();
                } else {
                    fetchNfo();
                }
            } catch(InvalidLibraryException e) {
                LOG.debug("The library is invalid and cannot be loaded, aborting", e);
                retries = 0;
                downloadsFinished();
            } catch(IOException e) {
                // Carry on with what we've got
                LOG.debug("Error expanding or loading update", e);
                considerRetrying();
            } catch(VirusScanException e) {
                // The existing definitions might have been corrupted
                LOG.debug("Error loading update", e);
                FileUtils.forceDeleteRecursive(VirusUtils.getDatabaseDirectory());
                listeners.broadcast(new VirusDefinitionVersionEvent(0));
                considerRetrying();
            } finally {
                FileUtils.forceDeleteRecursive(temp);
            }
        }

        @Override
        public void downloadFailed(File incomplete) {
            LOG.debug("Unable to download update");
            considerRetrying();
        }
    }

    class NFOHandler implements VirusDefinitionHandler {
        @Override
        public void downloadSucceeded(File nfo) {
            try {
                NFOFile nfoFile = new NFOFile(nfo);
                doUpdates(nfoFile);
            } catch(FileNotFoundException e) {
                LOG.debugf(e, "Unable to load file {0}", nfo);
                considerRetrying();
            }
        }

        @Override
        public void downloadFailed(File incomplete) {
            LOG.debug("Unable to download nfo file");
            considerRetrying();
        }
    }    
    /**
     * Helper function for testing to get the location for where the memento will 
     *  be saved from and loaded to; 
     */
    File getMementoFile() {
        return mementoFile;
    }
}
